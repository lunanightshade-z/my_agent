# React Error #310 终极修复 - Hooks 调用顺序违规
**日期**: 2026-01-20  
**问题**: 用户在路由切换时出现 React Error #310  
**根本原因**: React Hooks 调用顺序违规 + 内存泄漏

## 问题诊断

### 错误信息
```
Error: Minified React error #310; visit https://reactjs.org/docs/error-decoder.html?invariant=310
```

Error #310 表示: **"React hooks were called in a different order than during the previous render"**

### 根本原因分析

#### 问题 1: AppLayout.jsx 中的 Hooks 顺序违规 (致命)

**错误代码**:
```javascript
const AppLayout = ({ children }) => {
  // ✓ 这些 hooks 每次都会执行
  const { thinkingEnabled, currentConversationId, messages, isStreaming } = useSelector(...);
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
  const [activeArtifact] = useState(null);
  const containerRef = useRef(null);

  // ❌ 条件返回 - 如果为真，后面的 hooks 不会执行
  if (!isChatPage) {
    return <div>...</div>;
  }

  // ❌ 这个 useEffect 只在 isChatPage === true 时执行
  // 但当用户从 /chat 切换到 / 时，hooks 数量从 N 变成 N-1
  useEffect(() => {
    // 视差鼠标跟踪
  }, []);  // ← 错误的依赖数组！应该是 [isChatPage]
};
```

**问题**:
1. 第一次渲染 (Chat 页面): 执行 4 个 useState/useRef + 1 个 useEffect = 5 个 hooks
2. 切换到首页: 早期返回，只执行 4 个 useState/useRef = 4 个 hooks
3. React 检测到 hooks 数量变化 → **Error #310**

#### 问题 2: Home.jsx RevealOnScroll 的内存泄漏

**错误代码**:
```javascript
useEffect(() => {
  const observer = new IntersectionObserver(([entry]) => {
    if (entry.isIntersecting) {
      // ❌ setTimeout ID 没有被保存
      setTimeout(() => setIsVisible(true), delay);
    }
  });
  if (ref.current) observer.observe(ref.current);
  return () => observer.disconnect();  // ❌ 没有清理 timeout
}, [delay]);
```

**问题**:
- 组件卸载时，timeout 仍在运行
- 当 timeout 触发并调用 setState 时，React 警告 "Cannot perform a React state update on an unmounted component"
- 这引发额外的错误和不稳定性

## 修复方案

### 修复 1: AppLayout.jsx - 移动 useEffect 到条件返回之前

**修复步骤**:

1. 将所有 useEffect 移到条件返回之前
2. 在 useEffect 内部判断 isChatPage 状态
3. 更新依赖数组包含 isChatPage

**修复代码**:
```javascript
const AppLayout = ({ children }) => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const location = useLocation();
  const isChatPage = location.pathname === '/chat';
  const showMagicNavbar = !isChatPage;

  // ✓ 这些 hooks 每次都会执行
  const { thinkingEnabled, currentConversationId, messages, isStreaming } = useSelector(
    (state) => state.chat
  );
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
  const [activeArtifact] = useState(null);
  const containerRef = useRef(null);

  // ✓ useEffect 现在在条件返回之前定义！
  useEffect(() => {
    if (!isChatPage) return; // 早期返回，不执行任何逻辑
    
    let throttleTimer;
    let lastX = 0;
    let lastY = 0;

    const handleMouseMove = (e) => {
      if (!containerRef.current) return;
      if (throttleTimer) return;

      throttleTimer = setTimeout(() => {
        const { innerWidth, innerHeight } = window;
        const x = (e.clientX - innerWidth / 2) / innerWidth;
        const y = (e.clientY - innerHeight / 2) / innerHeight;

        const dx = Math.abs(x - lastX);
        const dy = Math.abs(y - lastY);

        if (dx > 0.01 || dy > 0.01) {
          lastX = x;
          lastY = y;
          setMousePos({ x, y });
        }

        throttleTimer = null;
      }, 16);
    };

    window.addEventListener('mousemove', handleMouseMove);
    return () => {
      window.removeEventListener('mousemove', handleMouseMove);
      if (throttleTimer) clearTimeout(throttleTimer);
    };
  }, [isChatPage]); // ✓ 正确的依赖数组

  // ✓ 现在可以安全地进行条件返回
  if (!isChatPage) {
    return (
      <div className="relative w-full min-h-screen overflow-hidden">
        {showMagicNavbar && <MagicNavbar />}
        <div className={showMagicNavbar ? 'pt-24' : ''}>
          {children}
        </div>
      </div>
    );
  }

  // Chat 页面：使用原本的 SYNTH AI 布局样式
  // ... rest of the component
};
```

### 修复 2: Home.jsx - 清理 setTimeout

**修复代码**:
```javascript
const RevealOnScroll = ({ children, delay = 0 }) => {
  const [isVisible, setIsVisible] = useState(false);
  const ref = useRef(null);

  useEffect(() => {
    let timeoutId;  // ✓ 保存 timeout ID
    
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          timeoutId = setTimeout(() => setIsVisible(true), delay);  // ✓ 保存 ID
        }
      },
      { threshold: 0.1 }
    );
    
    if (ref.current) observer.observe(ref.current);
    
    return () => {
      observer.disconnect();
      if (timeoutId) clearTimeout(timeoutId);  // ✓ 清理 timeout
    };
  }, [delay]);

  return (
    <div ref={ref} className={`ink-reveal ${isVisible ? 'visible' : ''}`}>
      {children}
    </div>
  );
};
```

## React Hooks 规则回顾

### 核心原则

1. **Hooks 数量不能变化**
   - 不能在条件语句内定义 hooks
   - 不能在循环内定义 hooks
   - 每次渲染时 hooks 数量必须相同

2. **正确的做法**:
   - 在组件函数体的顶层定义 hooks
   - 如果需要条件执行，在 hook 内部进行条件判断

3. **错误示例**:
```javascript
// ❌ 错误：条件内定义 hooks
function Component() {
  if (someCondition) {
    useEffect(() => { ... });  // Error #310!
  }
}

// ❌ 错误：循环内定义 hooks
function Component() {
  for (let i = 0; i < 5; i++) {
    useState(i);  // Error #310!
  }
}

// ✓ 正确：在顶层定义，条件判断在内部
function Component() {
  useEffect(() => {
    if (someCondition) {
      // 执行逻辑
    }
  }, [someCondition]);
}
```

## 修改文件清单

| 文件 | 修复内容 |
|------|---------|
| `frontend/src/components/layout/AppLayout.jsx` | 移动 useEffect 到条件返回之前 |
| `frontend/src/pages/Home.jsx` | 清理 setTimeout 防止内存泄漏 |

## 测试验证

### 预期行为修复后:
1. ✅ 首页能正常加载
2. ✅ 点击"Awaken The Magic"进入 Chat 页面无错误
3. ✅ 点击返回首页按钮无错误
4. ✅ 重复切换 10+ 次，保持稳定
5. ✅ 浏览器控制台无 React warnings 或 Error #310

### 容器验证
```
✓ 前端编译成功
✓ Docker 部署成功
✓ 三个容器正常运行:
  - ai_agent_api (后端)
  - ai_agent_nginx (前端 + 反向代理)
  - ai_agent_redis (缓存)
```

## 技术深度分析

### 为什么会发生 Error #310?

React 使用 **Fiber 架构** 来跟踪每个组件的状态：

1. **Hooks 链表**: React 为每个组件维护一个链表，链表中的每个节点代表一个 hook
2. **调用顺序很关键**: React 通过调用顺序来识别哪个 hook 是哪个状态
3. **顺序变化 = 状态混乱**: 如果 hooks 顺序改变了，React 会将状态分配给错误的 hook

**具体例子**:
```javascript
// 第一次渲染 (isChatPage = true):
// Hook 链表: [useSelector] → [useState] → [useState] → [useRef] → [useEffect]

// 用户导航到首页 (isChatPage = false):
// Hook 链表: [useSelector] → [useState] → [useState] → [useRef]
// ❌ useEffect 消失了！

// React 发现 hooks 数量从 5 变成 4 → Error #310
```

### 为什么修复方法有效?

**修复后的 hooks 链表**:
```javascript
// 第一次渲染 (isChatPage = true):
// Hook 链表: [useSelector] → [useState] → [useState] → [useRef] → [useEffect]

// 用户导航到首页 (isChatPage = false):
// Hook 链表: [useSelector] → [useState] → [useState] → [useRef] → [useEffect]
// ✓ useEffect 仍然存在，但在内部检查 isChatPage 并提前返回
```

现在 hooks 链表保持一致，React 不会产生错误！

## 最佳实践建议

1. **永远在顶层定义 hooks**
   ```javascript
   function Component() {
     // ✓ 顶层
     useEffect(() => { ... });
   }
   ```

2. **需要条件执行时，在 hook 内部进行**
   ```javascript
   function Component({ condition }) {
     useEffect(() => {
       if (!condition) return;  // ✓ 在内部判断
       // 执行逻辑
     }, [condition]);
   }
   ```

3. **清理副作用和定时器**
   ```javascript
   useEffect(() => {
     let timeoutId;
     const timer = setTimeout(() => { ... }, 1000);
     return () => {
       clearTimeout(timer);  // ✓ 清理
       if (timeoutId) clearTimeout(timeoutId);
     };
   }, []);
   ```

## 相关资源

- [React Hooks Rules](https://reactjs.org/docs/hooks-rules.html)
- [Error Decoder #310](https://reactjs.org/docs/error-decoder.html?invariant=310)
- [Hooks API Reference](https://reactjs.org/docs/hooks-state.html)
