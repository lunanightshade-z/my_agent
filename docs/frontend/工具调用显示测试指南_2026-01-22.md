# Agent 工具调用显示测试指南

## 修复检查清单

### ✅ 已完成的修复

1. **Redux Store 修复** (`frontend/src/store/store.js`)
   - ✅ `addToolCall` action 现在正确设置 `tool_name` 和 `tool_arguments` 字段
   - ✅ `updateToolResult` action 使用更可靠的匹配逻辑
   - ✅ 增强了错误处理和日志

2. **Agent 页面调试日志** (`frontend/src/pages/Agent.jsx`)
   - ✅ 在消息渲染时添加工具调用日志
   - ✅ 在 API 回调中添加详细日志（带 emoji 前缀区分）
   - ✅ 消息加载和状态更新都有对应日志

3. **SSE 解析改进** (`frontend/src/services/api.js`)
   - ✅ 为每个数据类型添加详细日志
   - ✅ 改进错误处理
   - ✅ 添加未处理类型的警告

4. **前端构建验证**
   - ✅ 前端项目成功构建，无错误或严重警告

5. **后端代码验证**
   - ✅ Python 代码语法正确
   - ✅ 数据格式一致

## 手动测试步骤

### 1. 启动应用

```bash
# 确保后端和前端都在运行
# 后端: http://localhost:8000
# 前端: http://localhost:5173
```

### 2. 打开浏览器开发者工具

- 按 `F12` 或 `Ctrl+Shift+I` 打开开发者工具
- 切换到 **Console** 标签页

### 3. 发送触发工具调用的消息

在 Agent 页面的输入框中发送以下类型的消息：
- "获取最新的新闻"
- "搜索关于 AI 的新闻"
- "帮我查找最新资讯"

### 4. 观察控制台日志

应该看到以下日志序列：

```
📝 [API] 收到内容块...  (可能有多次)
🔧 [API] 收到工具调用: {...}
  tool_name: "fetch_rss_news" 或其他工具名
  has_tool_arguments: true
🔧 [API] 工具调用完整数据: {...}
📡 [SSE Parser] 收到数据类型: tool_call
🔧 [SSE Parser] 解析工具调用: {...}
addToolCall action: {...}
最后一条消息: {...}
添加工具调用: {...}
工具调用列表: [...]
消息 N 有1个工具调用: [...]
渲染工具调用 0: {...}
✅ [API] 收到工具结果: {...}
✅ [API] 工具结果完整数据: {...}
📡 [SSE Parser] 收到数据类型: tool_result
updateToolResult action: {...}
找到工具调用索引: 0 工具名称: fetch_rss_news
工具调用结果已更新: {...}
```

### 5. 观察 UI 显示

#### 在流式响应过程中：
- ✅ 工具调用卡片应该在回答之前显示
- ✅ 卡片显示工具名称（如 "fetch_rss_news"）
- ✅ 卡片显示 "执行中..." 状态
- ✅ 有一个旋转的 Loader 图标

#### 在工具执行完成后：
- ✅ 卡片状态改为 "执行完成"
- ✅ 可以展开查看工具参数和结果
- ✅ 结果显示工具返回的数据

### 6. 验证历史消息

- 刷新页面
- 选择之前的对话
- ✅ 工具调用信息应该被保存和显示

## 故障排除

### 如果工具调用卡片没有显示

#### Step 1: 检查 SSE 流
```javascript
// 在浏览器 Network 标签中：
// 1. 查找 `/agent/stream` 请求
// 2. 检查响应中是否包含 `"type":"tool_call"`
// 3. 检查 `tool_name` 和 `tool_arguments` 字段是否存在
```

#### Step 2: 检查 Redux 状态
```javascript
// 在浏览器 Console 中运行：
// (假设使用了 Redux DevTools)
// 1. 打开 Redux DevTools
// 2. 查找 chat/addToolCall action
// 3. 检查 payload 中是否包含 tool_name
```

#### Step 3: 检查组件 Props
```javascript
// 在 ToolCallCard 组件中添加临时日志：
console.log('ToolCallCard props:', { toolCall, toolResult, isExecuting });
```

#### Step 4: 检查消息对象
```javascript
// 在浏览器 Console 中运行：
// (假设应用使用了 Redux)
const state = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__?.state?.();
console.log('messages:', state?.chat?.messages);
// 查看最后一条消息的 toolCalls 数组
```

## 预期结果

修复完成后，应该能够：

✅ 实时看到工具调用过程
✅ 查看工具调用参数
✅ 看到工具执行状态变化
✅ 查看工具执行结果
✅ 历史记录中保存工具调用信息

## 性能考量

- 工具调用日志不会严重影响性能
- SSE 流式处理在高频率消息下仍然高效
- 工具调用卡片使用虚拟滚动可进一步优化（如需要）

## 后续改进

1. 添加工具调用的本地存储和导出
2. 添加工具调用超时处理
3. 实现工具调用结果缓存
4. 添加工具调用历史统计

## 相关文件修改总结

### 前端修改

| 文件 | 修改内容 |
|------|--------|
| `frontend/src/store/store.js` | 改进 `addToolCall` 和 `updateToolResult` actions，确保数据格式正确 |
| `frontend/src/pages/Agent.jsx` | 添加详细的调试日志，追踪工具调用过程 |
| `frontend/src/services/api.js` | 改进 SSE 数据解析，添加详细的错误处理和日志 |

### 后端验证

- ✅ 后端 Python 代码语法验证通过
- ✅ 数据格式验证正确（`tool_name` 和 `tool_arguments` 字段正确映射）

## 工具调用流程图

```
用户消息
  ↓
后端 Agent 处理
  ↓
需要调用工具？
  ├─ 是 → yield {"type": "tool_call", "tool_name": "...", "tool_arguments": {...}}
  │        ↓
  │     工具执行
  │        ↓
  │     yield {"type": "tool_result", "tool_name": "...", "content": "..."}
  │
  └─ 否 → 继续处理
           ↓
         yield {"type": "delta", "content": "..."} (多次)
           ↓
         yield {"type": "done"}
           ↓
前端 SSE 解析
  ├─ tool_call 类型
  │   ↓
  │ onToolCall 回调
  │   ↓
  │ dispatch(addToolCall)
  │   ↓
  │ Redux 更新消息 toolCalls 数组
  │   ↓
  │ React 重新渲染 ToolCallCard 组件
  │
  └─ tool_result 类型
      ↓
    onToolResult 回调
      ↓
    dispatch(updateToolResult)
      ↓
    Redux 更新工具调用结果
      ↓
    React 重新渲染卡片，显示结果
```
